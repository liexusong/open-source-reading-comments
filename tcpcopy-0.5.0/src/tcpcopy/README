
---------------------------------- IP Header -------------------------------------
struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
    __u8    ihl:4,
            version:4;
#elif defined (__BIG_ENDIAN_BITFIELD)
    __u8    version:4,
            ihl:4;
#endif
    __u8    tos;
    __be16  tot_len;
    __be16  id;
    __be16  frag_off;
    __u8    ttl;
    __u8    protocol;
    __be16  check;
    __be32  saddr;
    __be32  daddr;
};

 31                                     0
     |----|----|------|--|-------------------|----------
     |ver |ihl | -tos | -|    tot_len        |
     |----|----|------|--|-------------------|
     |       id          |   frag_off       -|
     |---------|---------|-------------------|
     |   ttl   |protocol |    check          | 20 Bytes
     |---------|---------|-------------------|
     |                saddr                  |
     |---------------------------------------|
     |                daddr                  |
     |---------------------------------------|----------
     |                                       |
    -|                options                | 40 Bytes
     |                                       |
     |---------------------------------------|

===============================================================================================
              IPv4 (Internel协议)头部
 
iphdr->version
    版本(4位)，目前的协议版本号是4,因此IP有时也称作IPv4。

iphdr->ihl
    首部长度(4位):首部长度指的是IP层头部占32 bit字的数目(也就是IP层头部包含多少个4字节 -- 32位),包括任何选项。由于它是一个4比特字段,因此首部最长为60个字节。普通IP数据报(没有任何选择项)字段的值是5 <==> 5 * 32 / 8 = 5 * 4 = 20 Bytes

iphdr->tos
    服务类型字段(8位): 服务类型(TOS)字段包括一个3 bit的优先权子字段(现在已被忽略)，4 bit的TOS子字段和1 bit未用位但必须置0。4 bit的TOS子字段分别代表:最小时延、最大吞吐量、最高可靠性和最
小费用。4 bit中只能设置其中1 bit。如果所有4 bit均为0,那么就意味着是一般服务。

iphdr->tot_len
    总长度字段(16位)是指整个IP数据报的长度,以字节为单位。利用首部长度字段和总长度字段,就可以知道 IP数据报中数据内容的起始位置和长度。由于该字段长16比特,所以IP数据报最长可达65535字节
     总长度字段是IP首部中必要的内容,因为一些数据链路(如以太网)需要填充一些数据以达到最小长度。尽管以太网的最小帧长为46字节,但是IP数据可能会更短。如果没有总长度字段,那么IP层就不知道46字节中有多少是IP数据报的内容。

iphdr->id
    标识字段(16位)唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。

iphdr->frag_off (16位)
    frag_off域的低13位 -- 分段偏移(Fragment offset)域指明了该分段在当前数据报中的什么位置上。除了一个数据报的最后一个分段以外，其他所有的分段(分片)必须是8字节的倍数。这是8字节是基本分段单位。由于该域有13个位，所以，每个数据报最多有8192个分段。因此，最大的数据报长度为65,536字节，比iphdr->tot_len域还要大1。

iphdr->frag_off的高3位
    (1) 比特0是保留的，必须为0；
    (2) 比特1是“更多分片”(MF -- More Fragment)标志。除了最后一片外，其他每个组成数据报的片都要把该比特置1。
    (3) 比特2是“不分片”(DF -- DonDon't Fragment)标志,如果将这一比特置1，IP将不对数据报进行分片,这时如果有需要进行分片的数据报到来，会丢弃此数据报并发送一个ICMP差错报文给起始端。
     
   |---|-------------|
   |DM0|   offset    |
   |---|-------------|
   15 1312          0 
       
    4个字节的32 bit值以下面的次序传输:首先是0~7bit,其次8~15bit,然后16~23bit,最后是24~31 bit。这种传输次序称作big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序,因此它又称作网络字节序。

-------------------------------- TCP Header ------------------------------------
struct tcphdr {
    __be16 source;
    __be16 dest;
    __be32 seq;
    __be32 ack_seq;
#if defined(__LITTLE_ENDIAN_BITFIELD)
    __u16   res1:4,
            doff:4,
            fin:1,
            syn:1,
            rst:1,
            psh:1,
            ack:1,
            urg:1,
            ece:1,
            cwr:1;
#elif defined(__BIG_ENDIAN_BITFIELD)
    __u16   doff:4,
            res1:4,
            cwr:1,
            ece:1,
            urg:1,
            ack:1,
            psh:1,
            rst:1,
            syn:1,
            fin:1;
#endif
    __be16 window;
    __be16 check;
    __be16 urg_ptr;
};


     |----------------|----------------|-------------
     |     source     |     dest       |
     |----------------|----------------|
     |               seq               |
     |---------------------------------|
     |               ack_seq           | 20 Bytes
     |----|----|------|----------------|
     |doff|res1|      |     window     |
     |----|----|------|----------------|
     |     check      |     urg_ptr    |
     |----------------|----------------|-------------
     |             options             | 4 Bytes
     |---------------------------------|   

                    TCP头 

tcphdr->source
    16位源端口号

tcphdr->dest
    16位目的端口号

tcphdr->seq
    表示此次发送的数据在整个报文段中的起始字节数。序号是32 bit的无符号数。为了安全起见，它的初始值是一个随机生成的数，它到达32位最大值后，又从零开始。

tcphdr->ack_seq
    指定的是下一个期望接收的字节，而不是已经正确接收到的最后一个字节。

tcphdr->doff
    TCP头长度，指明了在TCP头部包含多少个32位的字。此信息是必须的，因为options域的长度是可变的，所以整个TCP头部的长度也是变化的。从技术上讲，这个域实际上指明了数据部分在段内部的其起始地址(以32位字作为单位进行计量)，因为这个数值正好是按字为单位的TCP头部的长度，所以，二者的效果是等同的

tcphdr->res1为保留位

tcphdr->window
    是16位滑动窗口的大小，单位为字节，起始于确认序列号字段指明的值，这个值是接收端正期望接收的字节数，其最大值是63353字节。
    TCP中的流量控制是通过一个可变大小的滑动窗口来完成的。window域指定了从被确认的字节算起可以接收的多少个字节。window = 0也是合法的，这相当于说，到现在为止多达ack_seq-1个字节已经接收到了，但是接收方现在状态不佳，需要休息一下，等一会儿再继续接收更多的数据，谢谢。以后，接收方可以通过发送一个同样ack_seq但是window不为0的数据段，告诉发送方继续发送数据段。

tcphdr->check
    是检验和，覆盖了整个的TCP报文段，这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。

tcphdr->urg_ptr
    这个域被用来指示紧急数据在当前数据段中的位置，它是一个相对于当前序列号的字节偏移值。这个设施可以代替中断信息。 
   
fin, syn, rst, psh, ack, urg为6个标志位
    这6个位域已经保留了超过四分之一个世纪的时间而仍然原封未动，这样的事实正好也说明了TCP的设计者们考虑的是多么的周到。它们的含义如下：
    tcphdr->fin fin位被用于释放一个连接。它表示发送方已经没有数据要传输了。
    tcphdr->syn 同步序号，用来发起一个连接。syn位被用于建立连接的过程。在连接请求中，syn=1; ack=0表示该数据段没有使用捎带的确认域。连接应答捎带了一个确认，所以有syn=1; ack=1。本质上，syn位被用来表示connection request和connection accepted，然而进一步用ack位来区分这两种情况。 
    tcphdr->rst 该为用于重置一个已经混乱的连接，之所以会混乱，可能是由于主机崩溃，或者其他的原因。该位也可以被用来拒绝一个无效的数据段，或者拒绝一个连接请求。一般而言，如果你得到的数据段设置了rst位，那说明你这一端有了问题。 
    tcphdr->psh 接收方在收到数据后应立即请求将数据递交给应用程序，而不是将它缓冲起来直到整个缓冲区接收满为止(这样做的目的可能是为了效率的原因) 
    tcphdr->ack ack位被设置为1表示tcphdr->ack_seq是有效的。如果ack为0，则该数据段不包含确认信息，所以，tcphdr->ack_seq域应该被忽略。 
    tcphdr->urg 紧急指针有效 

    tcphdr->ece 用途暂时不明
    tcphdr->cwr 用途暂时不明
    内核源代码在函数tcp_transmit_skb()中建立tcp首部